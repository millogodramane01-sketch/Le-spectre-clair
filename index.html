<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tir Spatial - Record Global</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            background: #161b22;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 95vw;
        }
        canvas {
            background-color: #010409;
            border: 2px solid #30363d;
            border-radius: 8px;
            touch-action: none; /* Empêche le défilement lors du jeu mobile */
        }
        .info-panel {
            background: #21262d;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            margin-bottom: 1rem;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
        }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(45, 50, 60, 0.95);
            padding: 2rem 3rem;
            border-radius: 10px;
            border: 2px solid #58a6ff;
            text-align: center;
            font-size: 1.5rem;
            color: #58a6ff;
            z-index: 10;
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.5);
        }
        .start-button {
            padding: 0.75rem 2rem;
            background-color: #2ea44f;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: background-color 0.2s, transform 0.1s;
        }
        .start-button:hover {
            background-color: #2c974b;
        }
        .start-button:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>

<div id="game-container">
    <h1 class="text-2xl font-bold mb-4 text-center text-blue-400">Tir Spatial (Record Global)</h1>
    <div class="info-panel">
        <span class="text-yellow-400">Score: <span id="current-score">0</span></span>
        <span class="text-red-400">Record Global: <span id="global-record">0</span></span>
        <span class="text-gray-400 text-sm">ID Joueur: <span id="user-id">...</span></span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="game-message" class="game-message hidden">
        <p>Jeu Terminé!</p>
        <p id="final-score" class="my-3 text-white text-3xl"></p>
        <button id="startButton" class="start-button mt-4">Démarrer</button>
        <p class="mt-4 text-sm text-gray-400">Utilisez les touches (Flèches/ZQSD) ou glissez sur le mobile pour déplacer.</p>
    </div>
</div>

<!-- Firebase SDK Imports -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Variables Globales d'Authentification et Firestore ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    // setLogLevel('debug'); // Décommenter pour voir les logs Firestore

    const GLOBAL_RECORD_DOC_PATH = `/artifacts/${appId}/public/data/global_game_data/record_doc`;
    let globalHighScore = 0;
    let userId = 'anon';
    let isAuthReady = false;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('current-score');
    const globalRecordDisplay = document.getElementById('global-record');
    const finalScoreDisplay = document.getElementById('final-score');
    const messageBox = document.getElementById('game-message');
    const startButton = document.getElementById('startButton');
    const userIdDisplay = document.getElementById('user-id');

    // --- Configuration du Jeu ---
    let raf;
    let gameRunning = false;
    let score = 0;
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 600;

    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Redimensionnement réactif (très simple pour un jeu centré)
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const containerWidth = container.clientWidth;
        const scale = Math.min(containerWidth / CANVAS_WIDTH, window.innerHeight / CANVAS_HEIGHT, 1);

        canvas.style.width = `${CANVAS_WIDTH * scale}px`;
        canvas.style.height = `${CANVAS_HEIGHT * scale}px`;
    }
    window.addEventListener('resize', resizeCanvas);

    // --- Objets du Jeu ---
    class Player {
        constructor() {
            this.x = CANVAS_WIDTH / 2;
            this.y = CANVAS_HEIGHT - 30;
            this.width = 40;
            this.height = 20;
            this.speed = 5;
        }
        draw() {
            ctx.fillStyle = '#58a6ff'; // Bleu de l'espace
            ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            // Cockpit (triangle)
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - 15);
            ctx.lineTo(this.x + 10, this.y + 5);
            ctx.lineTo(this.x - 10, this.y + 5);
            ctx.closePath();
            ctx.fillStyle = '#c9d1d9';
            ctx.fill();
        }
        update(dx) {
            this.x += dx * this.speed;
            if (this.x < this.width / 2) this.x = this.width / 2;
            if (this.x > CANVAS_WIDTH - this.width / 2) this.x = CANVAS_WIDTH - this.width / 2;
        }
    }

    class Bullet {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.radius = 3;
            this.speed = 7;
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#ff7b72'; // Rouge vif
            ctx.fill();
        }
        update() {
            this.y -= this.speed;
        }
    }

    class Enemy {
        constructor() {
            this.x = Math.random() * CANVAS_WIDTH;
            this.y = -20;
            this.size = 20 + Math.random() * 15;
            this.speed = 1 + Math.random() * 1.5;
            this.color = `hsl(${Math.random() * 60 + 200}, 70%, 50%)`; // Couleurs froides pour les ennemis
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
            ctx.closePath();
            ctx.fill();
        }
        update() {
            this.y += this.speed;
        }
    }

    let player;
    let bullets = [];
    let enemies = [];
    let enemySpawnTimer = 0;
    const ENEMY_SPAWN_INTERVAL = 60; // Spawn un ennemi toutes les 60 frames

    // --- Fonctions de Jeu ---

    function resetGame() {
        player = new Player();
        bullets = [];
        enemies = [];
        score = 0;
        enemySpawnTimer = 0;
        scoreDisplay.textContent = score;
        messageBox.classList.add('hidden');
        gameRunning = true;
        
        // Initialiser l'animation
        if (raf) window.cancelAnimationFrame(raf);
        gameLoop();
    }

    function checkCollision(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (obj1.radius || obj1.width / 2) + (obj2.radius || obj2.size / 2);
    }

    function endGame() {
        gameRunning = false;
        window.cancelAnimationFrame(raf);

        finalScoreDisplay.textContent = `Votre Score: ${score}`;
        messageBox.classList.remove('hidden');

        // *** LOGIQUE FIREBASE CRITIQUE : Vérification et mise à jour du record global ***
        if (isAuthReady) {
            checkAndUpdateGlobalHighScore(score);
        } else {
            console.warn("Authentication non prête, impossible de vérifier/mettre à jour le record global.");
        }
    }
    
    function gameLoop() {
        if (!gameRunning) return;

        // Effacer le canvas (espace noir)
        ctx.fillStyle = '#010409';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // --- Gestion des Ennemis ---
        enemySpawnTimer++;
        if (enemySpawnTimer >= ENEMY_SPAWN_INTERVAL) {
            enemies.push(new Enemy());
            enemySpawnTimer = 0;
        }

        // Mise à jour et dessin des balles
        bullets.forEach((bullet, i) => {
            bullet.update();
            bullet.draw();
            // Supprimer les balles hors écran
            if (bullet.y < 0) bullets.splice(i, 1);
        });

        // Mise à jour et dessin des ennemis
        enemies.forEach((enemy, i) => {
            enemy.update();
            enemy.draw();

            // Collision Joueur-Ennemi (Fin de partie)
            if (checkCollision(player, enemy)) {
                return endGame();
            }

            // Collision Balle-Ennemi
            bullets.forEach((bullet, j) => {
                if (checkCollision(bullet, enemy)) {
                    // Collision détectée
                    enemies.splice(i, 1); // Supprimer l'ennemi
                    bullets.splice(j, 1); // Supprimer la balle
                    score += 10;
                    scoreDisplay.textContent = score;
                }
            });

            // Ennemi hors écran (perdu)
            if (enemy.y > CANVAS_HEIGHT) {
                enemies.splice(i, 1);
                // Si l'ennemi atteint le bas, la partie est terminée
                return endGame(); 
            }
        });

        // Dessin du joueur
        player.draw();

        raf = window.requestAnimationFrame(gameLoop);
    }

    // --- Contrôles (Clavier) ---
    const keys = {};
    window.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        handleControls();
    });
    window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    function handleControls() {
        let dx = 0;
        // ZQSD ou Flèches
        if (keys['ArrowLeft'] || keys['q'] || keys['Q'] || keys['a'] || keys['A']) dx = -1;
        if (keys['ArrowRight'] || keys['d'] || keys['D']) dx = 1;
        player.update(dx);

        // Tir
        if (keys[' '] || keys['ArrowUp'] || keys['z'] || keys['Z'] || keys['w'] || keys['W']) {
            // Limiter le taux de tir
            if (bullets.length === 0 || player.y - bullets[bullets.length - 1].y > 20) {
                bullets.push(new Bullet(player.x, player.y - 15));
            }
        }
    }
    // Appel régulier pour la mise à jour des mouvements continus
    setInterval(handleControls, 1000 / 60);


    // --- Contrôles (Mobile/Tactile) ---
    let lastTouchX = null;
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        lastTouchX = e.touches[0].clientX;
        // Tirer immédiatement au toucher
        bullets.push(new Bullet(player.x, player.y - 15));
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const currentTouchX = e.touches[0].clientX;
        const canvasRect = canvas.getBoundingClientRect();
        const scale = CANVAS_WIDTH / canvasRect.width;

        if (lastTouchX !== null) {
            // Calculer le mouvement en coordonnées canvas
            const touchDeltaX = (currentTouchX - lastTouchX) * scale;
            
            // Mise à jour du joueur (mouvement proportionnel au glissement)
            player.x += touchDeltaX * 1.5; // Multiplicateur pour une meilleure réactivité

            // Clamper les limites du joueur
            if (player.x < player.width / 2) player.x = player.width / 2;
            if (player.x > CANVAS_WIDTH - player.width / 2) player.x = CANVAS_WIDTH - player.width / 2;
        }
        lastTouchX = currentTouchX;
    });

    canvas.addEventListener('touchend', () => {
        lastTouchX = null;
    });


    // --- LOGIQUE FIREBASE pour Record Global ---

    /**
     * Configure l'écouteur en temps réel pour le Record Global.
     * Met à jour la variable globale `globalHighScore` et l'affichage.
     * @param {Firestore} db L'instance Firestore.
     */
    function setupFirestoreListener(db) {
        const docRef = doc(db, GLOBAL_RECORD_DOC_PATH);

        // onSnapshot écoute le document en temps réel
        onSnapshot(docRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                // Assurez-vous que le score est un nombre, sinon 0
                globalHighScore = typeof data.score === 'number' ? data.score : 0;
                
                // Mettre à jour l'affichage pour tous les joueurs
                globalRecordDisplay.textContent = globalHighScore;
            } else {
                // Le document n'existe pas encore, on le crée
                globalHighScore = 0;
                setDoc(docRef, { score: 0, userId: 'system', lastUpdated: Date.now() }, { merge: true }).catch(console.error);
            }
        }, (error) => {
            console.error("Erreur lors de l'écoute du record global: ", error);
        });
    }

    /**
     * Vérifie si le score actuel est un nouveau record global et le met à jour dans Firestore.
     * @param {number} score Le score final de la partie.
     */
    async function checkAndUpdateGlobalHighScore(score) {
        if (score > globalHighScore) {
            const docRef = doc(db, GLOBAL_RECORD_DOC_PATH);
            try {
                // Envoie du nouveau record à Firestore
                await setDoc(docRef, {
                    score: score,
                    userId: userId,
                    lastUpdated: Date.now()
                }, { merge: true });
                // L'écouteur `onSnapshot` se chargera de mettre à jour la variable `globalHighScore` 
                // et l'affichage pour nous et tous les autres joueurs.
                console.log(`Nouveau record global potentiel (${score}) enregistré par ${userId}.`);
            } catch (e) {
                console.error("Erreur lors de la mise à jour du record global: ", e);
            }
        }
    }


    // --- Initialisation de l'Application ---
    window.onload = async function() {
        resizeCanvas();

        // 1. Authentification
        try {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Erreur d'authentification:", error);
            await signInAnonymously(auth); // Fallback
        }

        // 2. Écoute des changements d'état d'authentification
        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                userIdDisplay.textContent = user.uid.substring(0, 8) + '...'; // Afficher un extrait
                isAuthReady = true;
                console.log("Authentification complète. Démarrage de l'écoute Firestore.");
                // Démarrer l'écoute seulement après l'authentification
                setupFirestoreListener(db);
            } else {
                // Si non authentifié (très peu probable dans cet environnement), on utilise un ID temporaire
                userId = 'anon-' + (crypto.randomUUID ? crypto.randomUUID().substring(0, 8) : Date.now());
                userIdDisplay.textContent = userId;
                isAuthReady = true;
            }
        });

        // 3. Bouton Démarrer
        startButton.addEventListener('click', resetGame);

        // Afficher le message initial
        messageBox.classList.remove('hidden');
        finalScoreDisplay.textContent = `Record Global Actuel: ${globalHighScore}`;
    };

</script>

</body>
</html>
